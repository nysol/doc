
.. _はじめよう:

はじめよう
==================
簡単な例から始めよう。nysol_python をインストールしているのであれば、
pythonを起動し、例に従って入力し動作を確認してもらいたい。

以下では、:numref:`intable` に示される顧客の日別購買金額データを用いて簡単な実行例を示そう。
mcmdはこの様な表構造データを扱い、
現在のところ2重リストもしくはCSVのいずれかのフォーマットによって与える。

  .. csv-table:: 入力データ例:mcmdが扱う表構造データ
    :name: intable

    customer,date,amount
    A,20180101,5200
    B,20180101,4000
    B,20180101,3500
    A,20180101,2000
    B,20180101,800

まずは、mcmdモジュールをimportし、上記の表を二重リストとして ``dat`` 変数に格納しておく(:numref:`indat`)。

  .. code-block:: python
    :linenos:
    :caption: mcmdのインポートと入力データの設定
    :name: indat

    >>> import nysol.mcmd as nm
    >>> dat=[
    ["customer","date","amount"],
    ["A","20180101",5200],
    ["B","20180101",4000],
    ["B","20180101",3500],
    ["A","20180101",2000],
    ["B","20180101",800]
    ]

このデータから、顧客別に合計金額を合計する処理を以下に示す。
まずは、必要となる顧客と金額の2項目(``customer`` , ``amount`` )のみを切り出す(:numref:`cutCustAmount` )。
``mcut`` がその機能を実現するメソッドで、入力データとして ``dat`` 変数を指定している( ``i=`` )。
そして続けて ``run`` メソッドを指定することで ``mcut`` の処理が実行される。

  .. code-block:: python
    :linenos:
    :caption: 必要な項目の切り出し処理
    :name: cutCustAmount

    >>> nm.mcut(f="customer,amount",i=dat).run()
    >>> [['A', '5200'], ['B', '4000'], ['B', '3500'], ['A', '2000'], ['B', '800']]

切り出したデータについて、顧客別に金額を合計する処理は ``msum`` メソッドにより実現できる。
以下では、``mcut`` に続けて、msumを ``.`` (ドット)でつなげて指定しているが、
この書き方により、``mcut`` の出力結果が、``msum`` の入力として用いられることになる。
それぞれのメソッドはスレッド上で動作し、データはパイプ(FIFOキュー)によって接続されている[#f1]_。
詳細は mcmdオブジェクト<object> を参照されたい。

  .. code-block:: python
    :linenos:
    :caption: 顧客別金額合計の処理
    :name: custAmount

    >>> nm.mcut(f="customer,amount",i=dat).msum(k="customer",f="amount").run()
    [['A', '7200'], ['B', '8300']]

なお、上述の2つの実行結果のリストからは項目名が省かれているがこれは仕様である。
項目名を1要素目に出力したければ ``writelist`` 関数を用いれば実現できる。
mcmdでは、:numref:`custAmount` の例のようにメソッドを連結して段階的に処理を行うが、
メソッド間を流れるデータはPythonリストではなく、テキストのバイトストリームである。
そして、最後のメソッド(:numref:`custAmount` の例では ``msum`` )に明示的に出力ファイル ``o=`` を指定しなければ、
項目名ヘッダを省いたリストが出力されるようになっている。

組み合わせるmcmdメソッドの数が増えると、それらのメソッドをドットで繋げていくと見にくくなる。
また、途中にコメント書いたり、条件分岐で追加するメソッドを変更したりすることもできない。
そこで、同じ機能を ``<<=`` 演算子を使うことで、これらの問題を解決することができる。
:numref:`hello_ope` は、 :numref:`custAmount` と同様の処理を ``<<=`` 演算子で書き直したものである。
変数 ``f`` に次々と処理内容を追加登録し、最後に ``run`` メソッドで実行している。

  .. code-block:: python
    :linenos:
    :caption: ``<<=`` 演算子を利用した例
    :name: hello_ope

    >>> f=None
    >>> f <<= nm.mcut(f="customer,amount",i=dat)
    >>> f <<= nm.msum(k="customer",f="amount")
    >>> f.run()
    [['A', '7200'], ['B', '8300']]

複数のメソッドをより複雑に連結することも可能であり、詳細は「 :doc:`flow` 」の節を参照されたい。

リストの入出力 :command:`rm` は削除コマンド

CSVの入出力は :abbr:`LIFO (last-in, first-out)` を通じて行われる

繰り返し処理

逆引き

ソーティングキーの指定方法

sortingなどの自動追加の仕組みをどこかに入れる

結果全体を2重リストに出力、writelist(dtype=), writedictみたいなのはない。
=> 項目別の配列にするpythonの方法も書いておく。できれば転置して出力。

項目名の指定方法:文字列でもリストでもOK

.. [#f1] 正確には、処理フローオブジェクトに処理メソッド(mcutやmsum)を登録していっているだけで、最後のrunメソッドが登録された処理フローを実行している。詳しくは[処理フロー]を参照されたい。

