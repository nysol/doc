
.. _実行と並列処理:

実行と並列処理
=======================
処理フローオブジェクトに登録された処理フローの実行には、``run`` もしくは ``runs`` メソッドが用いられる。
各メソッドはthread上で動作し、接続が指定されたメソッド間にパイプラインが敷設される。
全てのthreadはMISD(Multiple Instruction Single Data)型の並列処理で実行される。
よって、処理フローの中で相対的に遅い処理メソッドがあれば、そこがボトルネックになる可能性もあるが、
より大規模な処理であれば、次節で紹介するSIMD(Single Instruction Multiple Data)型の並列処理と組み合わせることで、
より効率的な処理を実現できる。

``run`` は、実行前に自動追加される処理メソッドを加えた上で処理フローを構成する。
その後、各処理メソッドはthread上に展開され実行されるが、
処理メソッドがの数が多い場合は、それら全てが同時に実行されるわけではない。
メモリの圧迫や、ワークファイルの増加など、処理速度を低下させる要因が増え、効率が上がらなくなる。
さらに1プロセスで利用できるファイルのオープン数制限もある。(パイプもフィいるで、read,writeで2open)
そこで、同時実行thread数を経験的に制限している。
処理メソッドの平均的なメモリ利用量は47MB程度であり、実メモリ量を47MBで割った値を同時実行数として割り当てている。
他にどのようなプロセスが実行しているかは見ておらず、あくまでも物理的なメモリ要量から計算される。
例えば4GBメモリのマシンであれば、同時実行thread数の上限は86(=4084/47)となる。
この上限を変更することは可能で、2つの方法がある。
1つは、環境変数 ``KG_RUN_LIMIT`` にその値を設定することで、
もう一つは、 ``run`` の引数に ``runlimit`` を与えることである( :numref:`run_limit` )。
両方が同時に与えられた時は、 ``run`` の引数が優先される。

  .. code-block:: python
    :linenos:
    :caption: 同時実行thread数の上限変更の2つの方法
    :name: run_limit

    >>> import os
    >>> import nysol.mcmd as nm
    >>> os.environ['KG_RUN_LIMIT'] = '500' # 環境変数による設定
    >>> nm.mcut(f="a",i=dat).run(runlimit=500) # runの引数による設定
 
ある処理フローオブジェクトで実行される処理メソッドの数が上限を上回る場合には、
処理フローの「適当なところ」でフローを切断し(パイプ接続を切り)、
切断された箇所の結果をワークファイルへの出力に切り替える。
そして切断された先の処理は、前の全threadの処理が終わった後でワークファイルから読み込み、処理が継続されることになる。
極端な例として、``runlimit=1`` と設定すると、全てのメソッドは切断され、
全てのメソッドがシングルthreadで動作し、ファイル入出力でつながっていくことになる。

では処理フローを切断する「適当なところ」とはどのように決めているのであろうか？
mcmdの処理フローは循環のない有向グラフ(DAG:Directed Acyclic Graph)で表すことができる。
ただし、入力は複数あり、最終到達節点(最終出力)は1つになる。
その最後の１つの処理メソッドを追加した処理フローオブジェクトを ``.run()`` するのである。
そこで概ね、次のようなヒューリスティックで切断位置を決めている。
入力データから始め、DAG上を有向辺に沿って幅優先で巡回していき、
訪れた節点に番号を振っていく。
その番号がthread数の上限を超えたところで、現在のところたどり着いた節点を最終節点として切断する。
この操作を繰り返すことで、処理フロー全体を複数のブロックに分割し、順次threadの並列処理にて実行していっている。

以上のような切断方法以外にも、より処理効率を高めるための切断点の検出方法は存在するであろう。
ただ、各メソッドのアルゴリズムの処理効率、ワークファイル利用の有無、フローの分岐後の切断へのペナルティなど、
考慮すべき要因が多く、それらの要因を考慮した最適切断点の検出は今後の課題である。

runs([a,b,c])
------------------------
前節の ``run`` メソッドは、最終出力が1つの時に呼び出す処理フローオブジェクトのメンバーメソッドである。
複数の出力を伴う時は、
複数出力のある場合に使うrun

ブロックを見つける(島)
クラスメソッド
nm.run(a)=>これはできない

島が複数あったら、同時に動かすことになる。=>meachと同じ

runfuncはあくまでも1としてカウントしている。

メッセージ制御
------------------------
msg="on" "on"以外はoff

PTHREADで動く。
cmd,runfuncはthread上でforkしてプロセスとして起動される。

runsの利用方法
meach型も実現可能。

runとruns
----------------------------

実行と並列処理
----------------------------

KG_THREAD_STK=
デフォルト：1048576 (2の20上)
この整数倍を指定しなければならない。

KG_THREAD_STKですが
デフォルト値は1048576
指定できるのは
16384以上で1６の倍数になります
変な値だとOSによっては自動に調整されますが
macだと
#ERROR# ; kgshell (stack size change error );
になります

runで o=を指定したら出力ファイル名が返ってくることを言う。
リストの場合は空リスト

