
.. _実行と並列処理:

実行と並列処理
=======================
処理フローオブジェクトに登録された処理フローの実行には、``run`` もしくは ``runs`` メソッドが用いられる。
各メソッドはthread上で動作し、接続が指定されたメソッド間にパイプラインが敷設される。
全てのthreadはMISD(Multiple Instruction Single Data)型の並列処理で実行される。
よって、処理フローの中で相対的に遅い処理メソッドがあれば、そこがボトルネックになる可能性もあるが、
より大規模な処理であれば、次節で紹介するSIMD(Single Instruction Multiple Data)型の並列処理と組み合わせることで、
より効率的な処理を実現できる。

``run`` は、実行前に自動追加される処理メソッドを加えた上で処理フローを構成する。
その後、各処理メソッドはthread上に展開され実行されるが、
処理メソッドがの数が多い場合は、それら全てが同時に実行されるわけではない。
メモリの圧迫や、ワークファイルの増加など、処理速度を低下させる要因が増え、効率が上がらなくなる。
さらに1プロセスで利用できるファイルのオープン数制限もある。(パイプもフィいるで、read,writeで2open)
そこで、同時実行thread数を経験的に制限している。
処理メソッドの平均的なメモリ利用量は47MB程度であり、実メモリ量を47MBで割った値を同時実行数として割り当てている。
他にどのようなプロセスが実行しているかは見ておらず、あくまでも物理的なメモリ要量から計算される。
例えば4GBメモリのマシンであれば、同時実行thread数の上限は86(=4084/47)となる。
この上限を変更することは可能で、2つの方法がある。
1つは、環境変数 ``KG_RUN_LIMIT`` にその値を設定することで、
もう一つは、 ``run`` の引数に ``runlimit`` を与えることである( :numref:`run_limit` )。
両方が同時に与えられた時は、 ``run`` の引数が優先される。

  .. code-block:: python
    :linenos:
    :caption: 同時実行thread数の上限変更の2つの方法
    :name: run_limit

    >>> import os
    >>> import nysol.mcmd as nm
    >>> os.environ['KG_RUN_LIMIT'] = '500' # 環境変数による設定
    >>> nm.mcut(f="a",i=dat).run(runlimit=500) # runの引数による設定
 
ある処理フローオブジェクトで実行される処理メソッドの数が上限を上回る場合には、
処理フローの適当なところでフローを切り(パイプ接続を切り)、切られた箇所の結果をワークファイルへの出力に切り替える。
そして切られた先の処理は、前の全threadの処理が終わった後で、ワークファイルから読み込み処理が継続されることになる。
inから並べランクを付ける
幅優先でlimit以下のち天で切る

runs([a,b,c])
------------------------
複数出力のある場合に使うrun
ブロックを見つける(島)
クラスメソッド
nm.run(a)=>これはできない

島が複数あったら、同時に動かすことになる。=>meachと同じ

runfuncはあくまでも1としてカウントしている。

メッセージ制御
------------------------
msg="on" "on"以外はoff

runlimit=1だと内部で区切られ、シングルプロセスになり、ファイルがいっぱい作成される。
PTHREADで動く。
cmd,runfuncはthread上でforkしてプロセスとして起動される。

runsの利用方法
meach型も実現可能。

runとruns
----------------------------

実行と並列処理
----------------------------

KG_THREAD_STK=
デフォルト：1048576 (2の20上)
この整数倍を指定しなければならない。


